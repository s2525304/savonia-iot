#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}" )" && pwd)"

# Load base env
source "$SCRIPT_DIR/../azure.env"

# ------------------------------------------------------------------------------
# Helpers
# ------------------------------------------------------------------------------

require_var() {
	local name="$1"
	if [[ -z "${!name:-}" ]]; then
		echo "ERROR: Required env var '$name' is not set" >&2
		exit 1
	fi
}

require_cmd() {
	local name="$1"
	command -v "$name" >/dev/null 2>&1 || {
		echo "ERROR: Required command '$name' not found in PATH" >&2
		exit 1
	}
}

# Path for generated, shared env values
GENERATED_ENV="$SCRIPT_DIR/.generated.env"

ensure_generated_env() {
	if [[ -f "$GENERATED_ENV" ]]; then
		return 0
	fi

	cat > "$GENERATED_ENV" <<'EOF'
# ------------------------------------------------------------------------------
# AUTO-GENERATED FILE â€” DO NOT EDIT MANUALLY
# Generated by infra scripts. Safe to delete; it will be recreated.
# ------------------------------------------------------------------------------
EOF
}

load_generated_env() {
	[[ -f "$GENERATED_ENV" ]] && source "$GENERATED_ENV"
}

# JSON array -> newline-delimited keys (no jq dependency)
json_keys_to_lines() {
	python3 - <<'PY'
import json
import signal
import sys

# Prevent noisy stack traces when downstream consumers (e.g. `comm`) close the pipe early.
signal.signal(signal.SIGPIPE, signal.SIG_DFL)

try:
	data = json.load(sys.stdin)
except Exception:
	sys.exit(0)

try:
	for item in data or []:
		name = item.get("name")
		if name:
			print(name)
except BrokenPipeError:
	# Pipe closed by downstream command; exit quietly.
	try:
		sys.stdout.close()
	except Exception:
		pass
	sys.exit(0)
PY
}

# ------------------------------------------------------------------------------
# Preconditions
# ------------------------------------------------------------------------------

require_cmd az
require_cmd zip
require_cmd python3

require_var AZURE_SUBSCRIPTION_ID
require_var AZURE_RESOURCE_GROUP
require_var AZURE_LOCATION

require_var FUNCTIONAPP_NAME
require_var FUNCTIONAPP_STORAGE_ACCOUNT
require_var FUNCTIONAPP_NODE_VERSION
require_var FUNCTIONAPP_FUNCTIONS_VERSION

# Load derived values (produced by earlier scripts)
# NOTE: some required vars (e.g. STORAGE_CONNECTION_STRING, COLD_STORAGE_CONNECTION_STRING)
# are expected to come from .generated.env.
ensure_generated_env
load_generated_env

# Cold storage (blob-writer) settings required by config.ts
require_var COLD_STORAGE_CONNECTION_STRING
require_var COLD_CONTAINER

# Settings that functions need
require_var QUEUE_DB_WRITE
require_var QUEUE_ALERTS
require_var QUEUE_BLOB_BATCH

require_var POSTGRES_HOST
require_var POSTGRES_PORT
require_var POSTGRES_DATABASE
require_var POSTGRES_USER
require_var POSTGRES_PASSWORD
require_var POSTGRES_SSLMODE
require_var TIMESCALE_RETENTION_DAYS

require_var HTTP_API_KEY

# Must exist from storage/iothub/postgres scripts (or be provided some other way)
require_var STORAGE_CONNECTION_STRING
require_var IOTHUB_EVENTHUB_CONNECTION_STRING
require_var IOTHUB_EVENTHUB_NAME

# ------------------------------------------------------------------------------
# Azure context
# ------------------------------------------------------------------------------

echo "Using subscription: $AZURE_SUBSCRIPTION_ID"
az account set --subscription "$AZURE_SUBSCRIPTION_ID"

# ------------------------------------------------------------------------------
# Ensure Function App
# ------------------------------------------------------------------------------

if az functionapp show --name "$FUNCTIONAPP_NAME" --resource-group "$AZURE_RESOURCE_GROUP" >/dev/null 2>&1; then
	echo "Function App '$FUNCTIONAPP_NAME' already exists."
else
	echo "WARNING: A new Azure Function App will be created."
	echo "  Name     : $FUNCTIONAPP_NAME"
	echo "  Location : $AZURE_LOCATION"
	echo "  Runtime  : node"
	echo "  Node     : $FUNCTIONAPP_NODE_VERSION"
	echo "  Version  : $FUNCTIONAPP_FUNCTIONS_VERSION"
	echo
	echo "Press Ctrl+C within the next 10 seconds to cancel."
	sleep 10

	echo "Creating Function App '$FUNCTIONAPP_NAME'..."
	# Create a Consumption-plan Function App.
	# NOTE: On some setups, `az functionapp create` may create or reuse an implicit plan.
	az functionapp create \
		--name "$FUNCTIONAPP_NAME" \
		--resource-group "$AZURE_RESOURCE_GROUP" \
		--consumption-plan-location "$AZURE_LOCATION" \
		--runtime node \
		--runtime-version "$FUNCTIONAPP_NODE_VERSION" \
		--functions-version "$FUNCTIONAPP_FUNCTIONS_VERSION" \
		--storage-account "$FUNCTIONAPP_STORAGE_ACCOUNT" \
		--output none
	echo "Function App created."
fi

# ------------------------------------------------------------------------------
# App settings
# ------------------------------------------------------------------------------

# Managed keys list (used for diffing existing app settings)
managed_keys=(
	"AzureWebJobsStorage"
	"FUNCTIONS_WORKER_RUNTIME"
	"SCM_DO_BUILD_DURING_DEPLOYMENT"
	"ENABLE_ORYX_BUILD"
	"WEBSITE_RUN_FROM_PACKAGE"
	"QUEUE_DB_WRITE"
	"QUEUE_ALERTS"
	"QUEUE_BLOB_BATCH"
	"COLD_CONTAINER"
	"COLD_STORAGE_CONNECTION_STRING"
	"COLD_PREFIX"
	"COLD_GZIP"
	"POSTGRES_HOST"
	"POSTGRES_PORT"
	"POSTGRES_DATABASE"
	"POSTGRES_USER"
	"POSTGRES_PASSWORD"
	"POSTGRES_SSLMODE"
	"HTTP_API_KEY"
	"IOTHUB_EVENTHUB_CONNECTION_STRING"
	"IOTHUB_EVENTHUB_NAME"
	"TIMESCALE_RETENTION_DAYS"
)

# Cold storage settings
# - COLD_CONTAINER is required by config.ts (blob-writer)
# - COLD_PREFIX / COLD_GZIP are optional
COLD_PREFIX="${COLD_PREFIX:-telemetry}"
COLD_GZIP="${COLD_GZIP:-false}"

# Build appsettings args
settings_args=(
	"AzureWebJobsStorage=$STORAGE_CONNECTION_STRING"
	"FUNCTIONS_WORKER_RUNTIME=node"
	# Use Zip Deploy with remote build (Oryx). Run-from-package disables builds and causes TS-only deployments to appear empty.
	"WEBSITE_RUN_FROM_PACKAGE=0"
	"SCM_DO_BUILD_DURING_DEPLOYMENT=1"
	"ENABLE_ORYX_BUILD=true"
	"QUEUE_DB_WRITE=$QUEUE_DB_WRITE"
	"QUEUE_ALERTS=$QUEUE_ALERTS"
	"QUEUE_BLOB_BATCH=$QUEUE_BLOB_BATCH"
	"COLD_STORAGE_CONNECTION_STRING=$COLD_STORAGE_CONNECTION_STRING"
	"COLD_CONTAINER=$COLD_CONTAINER"
	"POSTGRES_HOST=$POSTGRES_HOST"
	"POSTGRES_PORT=$POSTGRES_PORT"
	"POSTGRES_DATABASE=$POSTGRES_DATABASE"
	"POSTGRES_USER=$POSTGRES_USER"
	"POSTGRES_PASSWORD=$POSTGRES_PASSWORD"
	"POSTGRES_SSLMODE=$POSTGRES_SSLMODE"
	"TIMESCALE_RETENTION_DAYS=$TIMESCALE_RETENTION_DAYS"
	"HTTP_API_KEY=$HTTP_API_KEY"
	"COLD_PREFIX=$COLD_PREFIX"
	"COLD_GZIP=$COLD_GZIP"
)

settings_args+=("IOTHUB_EVENTHUB_CONNECTION_STRING=$IOTHUB_EVENTHUB_CONNECTION_STRING")
settings_args+=("IOTHUB_EVENTHUB_NAME=$IOTHUB_EVENTHUB_NAME")

# Sync settings
# NOTE: This overwrites values for these keys but does not delete other keys.
echo "Setting Function App application settings (${#settings_args[@]})..."
az functionapp config appsettings set \
	--name "$FUNCTIONAPP_NAME" \
	--resource-group "$AZURE_RESOURCE_GROUP" \
	--settings "${settings_args[@]}" \
	--output none

echo "App settings updated."

# ------------------------------------------------------------------------------
# Deploy code (zip deploy)
# ------------------------------------------------------------------------------

FUNCTIONS_SRC_DIR="$SCRIPT_DIR/../functions"
if [[ ! -d "$FUNCTIONS_SRC_DIR" ]]; then
	echo "ERROR: Functions source directory not found: $FUNCTIONS_SRC_DIR" >&2
	exit 1
fi

TMP_ZIP="$(mktemp -t functionapp_deploy_XXXXXX).zip"
trap 'rm -f "$TMP_ZIP"' EXIT

# Create zip from functions directory
(
	cd "$FUNCTIONS_SRC_DIR"
	# Exclude common junk
	zip -r "$TMP_ZIP" . \
		-x "node_modules/*" \
		-x ".git/*" \
		-x ".DS_Store" \
		-x "build/*" \
		-x "coverage/*" \
		-x "*.log"
)

echo "Deploying Function App package (zip deploy)..."
az functionapp deployment source config-zip \
	--name "$FUNCTIONAPP_NAME" \
	--resource-group "$AZURE_RESOURCE_GROUP" \
	--src "$TMP_ZIP" \
	--output none

echo "Function App deployment triggered."

# ------------------------------------------------------------------------------
# List settings that exist in Azure but are not managed by this script
# ------------------------------------------------------------------------------

echo

echo "------------------------------------------------------------"
echo "App settings not managed by this script"
echo "(present in Azure, but not in managed_keys)"
echo "------------------------------------------------------------"

# Fetch current settings
current_keys="$(az functionapp config appsettings list \
	--name "$FUNCTIONAPP_NAME" \
	--resource-group "$AZURE_RESOURCE_GROUP" \
	--query "[].name" \
	--output tsv | sort)"

# Build managed keys list for comparison
managed_keys_sorted="$(printf "%s\n" "${managed_keys[@]}" | sort)"

# Diff (lines in current but not in managed)
extra_keys="$(comm -23 <(printf "%s\n" "$current_keys") <(printf "%s\n" "$managed_keys_sorted") || true)"

if [[ -z "${extra_keys// }" ]]; then
	echo "(none)"
else
	echo "$extra_keys"
fi

echo

echo "Function App setup complete."